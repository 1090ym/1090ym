{"posts":[{"title":"Java学习篇","content":"第一章 基本程序设计 输入输出 标准输入输出流： System.out：标准输出流OutputStream的对象 Seytem.in：标准输入流类InputStream的对象 Scanner类：Scanner scanner = new Scanner(System.in) 标识符由字母，下划线，数字，美元符号组成 必须以字母，下划线，美元符号开头 不能是保留字 常量：final datatype CONSTANT_NAME = value,常量的声明和初始化必须同时完成 数据类型 基本类型 整数类型：byte，short，int，long 字符类型：char 逻辑类型：boolean 引用类型：类class，接口interface，数组array 避免精度损失，数据转换总是向较大的数据类型进行转换。 将值赋给较小范围的变量时，必须使用强制类型转换 byte&lt;char&lt;short&lt;int&lt;long&lt;float&lt;double 操作上溢：infinity，操作下溢：0，0.0除0.0等于NaN 从对话框获得输入：import Javax.swing.JOptionPane String string = JOptionPane.showInputDialog(&quot;hello world&quot;) 选择 //圆括号内必须是求值结果为boolean的表达式 //if语句 if(bool-expression) statement //if-else,else与最近的匹配 if(bool-expressiom) statement1 else statement2 //switch语句 switch(expression){ case value1: statesment(s); break; case value2: statement(s); break; ··· default: statement(s); } 操作符的优先级 操作数的优先级：操作数从左至右进行运算 第二章 数学函数，字符串 Math类 math 是final类，在Java.lang.Math中，所有的数学函数都是静态方法 数学常量：PI，E 三角函数：sin cos tan asin acos atan toRadians toDigrees 指数：exp log log10 pow sqrt 取整：ceil floor round 其他：min max abs random([0.0, 1.0) 生成随机字符 a + (int)Math.random()*b 返回[a, a+b) a + (int)Math.random()*(b+1) 放回[a, a+b] 生成随机字符 char('a' + (int)Math.random()*('z' - 'a'+1)) 字符的比较和测试：character类 isDigit isLetter isLetterOrDigit isLowercase isUpperCase toLowercase toUpperCase String类：final类，不能被继承 构造：String str = new String(&quot;welcome&quot;); 简写：String str = &quot;welcome&quot;; 长度：length 获取字符：charAt 连接：concat 截取：substring 比较：equals equalsIngnoreCase compareTo startWith endWith regionMatch、 转换：toLowerCase, toUpperCase, trim, replace 查找：indexOf, lastIndexOf 字符串和数组转换：getChar, toCharArray 字符串和数字间转换：valueOf 规范字符串和常量池 为了提高效率和优化内存，Java中的字符串字面值维护在字符串常量池中，称为规范字符串 字符串创建后，其内容是不可修改的 字符串的比较 equals方法比较字符串的内容是否相同 equalsIgnoreCase忽略大小写比较内容是否相同 regionMatch比较部分内容是否相同 startWith判断是否以某个字符串开始 endWith判断是否以某个字符串结束 compareTo按照字典序比较两个字符串的大小 length获取字符串的长度 charAt(index)获取指定位置的字符 concat用于连接两个字符串，相当于+号、 subString(begin, end)：返回begin到end-1的子串 indeOf(string, index)：返回字符串中匹配的位置，-1表示未找到 valueOf(type)：基本数据类型转换为字符串 字符串转换为基本类型：使用包装类Double.parseDouble(str), Integer.parseInteger(str) StringBuffer与StringBuilder：final类 ","link":"https://1090ym.github.io/post/java-xue-xi-pian/"},{"title":"计算机系统结构 第一章","content":"系统结构基础 理论基础：图灵机 处理：读写头 存储：无限长的带子 传输：带子的移动 结构基础：冯诺伊曼结构 物质基础：摩尔定律 加快经常性事件 CISC 采用新指令 用硬件替代软件，指令替代子程序 复杂的指令集 复杂的指令集 较少的寄存器 简洁的软件代码 RISC 90%的时间使用的是10%的指令 精简的指令集 更简单的硬件 较多的寄存器 更多的软件代码 高速缓存Cache 利用局部性原理 使访存的速度和处理器的速度匹配 Amdahl定律 加速比： Sn=新速度老速度=新时间老时间=ToTnS_n = \\frac{新速度}{老速度} = \\frac{新时间}{老时间} = \\frac{T_o}{T_n} Sn​=老速度新速度​=老时间新时间​=Tn​To​​ 基本Amdahl定律： Sn=1(1−Fe)+FeSeS_n = \\frac{1}{(1-F_e)+\\frac{F_e}{S_e}} Sn​=(1−Fe​)+Se​Fe​​1​ Fe：被改进部分原执行时间占原总时间的百分比F_e：被改进部分原执行时间占原总时间的百分比 Fe​：被改进部分原执行时间占原总时间的百分比 Se：被改进部分的部件加速比 S_e：被改进部分的部件加速比 Se​：被改进部分的部件加速比 Amdahl定律的性能递减规则： 如果仅仅对计算机中的一部分进行性能改进，则改进越多，提升的性能越有限。 为使系统获得较高的加速比，可增强部分必须占有较大比例。 CPU性能公式 CPU时间 ＝ IC ＊ CPI ＊ 时钟周期时间 局部性原理 时间局部性：一个信息项正在被访问,那么近期它有可能再次被访问。 空间局部性：程序即将用到的信息很可能与目前正在使用的信息在空间上相邻。 高速缓存Cache利用了空间局部性。 并行性 处理数据角度：字串位串，字串位并，字并位串，全并行 执行程序角度：指令内部并行，指令级并行，线程级并行，任务级或过程级并行，作业或程序级并行。 提高并行性: 时间重叠 资源重复 资源共享 计算机系统评价 性能（快） 用户角度：响应时间 管理员角度：吞吐率 MIPS 程序执行时间 MFLOPS 基准测试程序 基准测试程序套件 成本 功耗 云端：电力成本 终端：待机时间 可靠性 MTTF 冯诺依曼结构的改进 输入输出方式的改进： 程序控制 程序等待 程序中断 DMA直接访问存储器 I／O处理机 采用并行处理技术 存储器：采用相联存储器，通用寄存器组，高速缓冲存储器 指令系统：CISC，RISC ","link":"https://1090ym.github.io/post/ji-suan-ji-xi-tong-jie-gou-di-yi-zhang/"},{"title":"JAVA学习篇：环境搭建","content":"语言特征 简单：源于c++，进行简化 面向对象：没有全局变量，全局函数等 分布式：可基于Java RMI，Java RPC编写分布式程序 解释性：编译成字节码，在java虚拟机上运行 健壮性：取消指针，垃圾自动回收，异常处理 安全性：安全机制保护 可移植性好 高性能：分布式计算，高并发 多线程 与体系结构无关 java版本 Java SE：适用于开发桌面java程序 Java EE：适用于开发服务端java程序 Java ME：移动是被和嵌入式设备 Java运行环境：JVM 安装JDK，创建、编译和执行Jav程序 下载稳定版java SE：https://www.oracle.com/technetwork/java/javase/downloads/index.html 下载API帮助文档 安装JDK 配置环境变量：新建环境变量JAVA_HOME，然后把JDK安装路径添加到JAVA_HOME环境变量中 再将%JAVA_HOME%/bin添加到环境变量PATH中 在cmd中输入java -version查看是否安装成功 ","link":"https://1090ym.github.io/post/java-xue-xi-pian-huan-jing-da-jian/"},{"title":"git入门","content":"创建git仓库 mkdir 仓库名 进入目录 cd 目录名 查看目录 pwd 命令把这个目录变成Git可以管理的仓库 第一步，通过git init命令控制仓库 第二步，用命令git add告诉Git，把文件添加到仓库：git add readme.txt 第三步，用命令git commit告诉Git，把文件提交到仓库：git commit -m &quot;wrote a readme file&quot; 查看git工作状态和修改情况 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容 git版本回退 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id 回退到上个版本：git reset --hard HEAD^,上上个版本git reset --hard HEAD^^ 查看版本id：git log --pretty=oneline 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区 git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支 ##撤销和修改 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 删除文件 命令git rm filename用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容 恢复：git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 git推送到远程仓库 关联远程库： git remote add origin git仓库网址 或者 git remote add origin git@github.com:用户名/git仓库名 推送本地库到远程库：git push -u origin master 输入上一步命令后，只要本地做了提交，使用git push origin master就可以把本地master分支的最新修改推送至GitHub 注意：如果输入$ git remote add origin git@github.com:djqiang（github帐号名）/gitdemo（项目名）.git 提示出错信息：fatal: remote origin already exists. 解决办法如下： 1、先输入$ git remote rm origin 2、再输入$ git remote add origin git@github.com:djqiang/gitdemo.git 就不会报错了！ 3、如果输入$ git remote rm origin 还是报错的话，error: Could not remove config section 'remote.origin'. 我们需要修改gitconfig文件的内容 4找到你的github的安装路径，找到一个名为gitconfig的文件，打开它把里面的[remote &quot;origin&quot;]那一行删掉就好了！ 克隆远程库 git clone git@github.com:用户名/仓库名.git 分支管理 Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; git分支合并出现冲突 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log --graph --pretty=oneline --abbrev-commit命令可以看到分支合并图。 git暂存分支 先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动 查看远程库 查看远程库信息：git remote -v 推送本地分支：$ git push origin master 克隆远程分支：git clone git@github.com:用户名/仓库名.git 创建远程origin的dev分支到本地：git checkout -b dev origin/dev 多人协作 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 出现的问题： 出现错误：fatal: refusing to merge unrelated histories 因为两个分支没有取得连续：git pull origin master --allow-unrelated-histories ","link":"https://1090ym.github.io/post/git-ru-men/"},{"title":"第一篇博客","content":"📝开始写博客啦。😄❤️ ","link":"https://1090ym.github.io/post/di-yi-pian-bo-ke/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://1090ym.github.io/post/hello-gridea/"}]}